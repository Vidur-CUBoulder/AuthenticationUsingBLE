//=========================================================
// src/InitDevice.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include "InitDevice.h"

// USER PROTOTYPES
// USER FUNCTIONS

// $[Library includes]
#include "em_system.h"
#include "em_emu.h"
#include "em_cmu.h"
#include "em_device.h"
#include "em_chip.h"
#include "em_assert.h"
#include "em_crypto.h"
#include "em_gpcrc.h"
#include "em_gpio.h"
#include "em_ldma.h"
#include "em_prs.h"
#include "em_rtcc.h"
#include "em_leuart.h"
#include "retargetserial.h"

#include "sl_crypto.h"
#include "cryptodrv.h"

#include "aes.h"

#define AES_DATA_SIZE 64
#define AES_BLOCK_SZ 16

uint8_t Storage_Buffer[AES_DATA_SIZE];

#if 1
const uint8_t exampleKey[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

uint8_t example_input_data[AES_BLOCK_SZ] = {0x03,0x36,0x76,0x3e,0x96,0x6d,0x92,0x59,0x5a,0x56,0x7c,0xc9,0xce,0x53,0x7f,0x5e};

uint8_t decryptionKey[16];

uint8_t pop_data[64];

const uint8_t initVector[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
                               0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};
#endif

/** LDMA Descriptor initialization */
static LDMA_Descriptor_t xfer =
		LDMA_DESCRIPTOR_LINKREL_P2M_BYTE(&LEUART0->RXDATA, /* Peripheral source address */
				&Storage_Buffer,  /* Peripheral destination address */
				AES_DATA_SIZE,    /* Number of bytes */
				0);               /* Link to same descriptor */

/* Global aes data structure */
mbedtls_aes_context aes_ctx;

// [Library includes]$

//==============================================================================
// enter_DefaultMode_from_RESET
//==============================================================================
extern void enter_DefaultMode_from_RESET(void) {
	// $[Config Calls]
	CHIP_Init();

	EMU_enter_DefaultMode_from_RESET();
	LFXO_enter_DefaultMode_from_RESET();
	CMU_enter_DefaultMode_from_RESET();
	RTCC_enter_DefaultMode_from_RESET();
	GPCRC_enter_DefaultMode_from_RESET();
	LDMA_enter_DefaultMode_from_RESET();
	PRS_enter_DefaultMode_from_RESET();
	PORTIO_enter_DefaultMode_from_RESET();
	//CRYPTO_enter_DefaultMode();
	// [Config Calls]$

}

//================================================================================
// EMU_enter_DefaultMode_from_RESET
//================================================================================

extern void Setup_CRYPTO(void) {

	uint8_t ret;

	/* Switch HFCLK to HFXO and disable HFRCO */
	CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO);
	CMU_OscillatorEnable(cmuOsc_HFRCO, false, false);

	/* Enable the clock to the CRYPTO engine */
	CMU->HFBUSCLKEN0 = CMU_HFBUSCLKEN0_CRYPTO;

	/* Init mbedtls */
	mbedtls_aes_init(&aes_ctx);

	/* Get the decryption key from the original key, needs to be done once for each key */
	//CRYPTO_AES_DecryptKey128(CRYPTO, decryptionKey, exampleKey);

	do{
		ret = mbedtls_aes_setkey_dec( &aes_ctx, exampleKey, 128 );
	} while(MBEDTLS_ECODE_CRYPTODRV_BUSY == ret);

	return;
}

extern void EMU_enter_DefaultMode_from_RESET(void) {

	// $[EMU Initialization]
	/* Initialize DCDC regulator */
	EMU_DCDCInit_TypeDef dcdcInit = EMU_DCDCINIT_DEFAULT;

	dcdcInit.powerConfig = emuPowerConfig_DcdcToDvdd;
	dcdcInit.dcdcMode = emuDcdcMode_LowNoise;
	dcdcInit.mVout = 1800;
	dcdcInit.em01LoadCurrent_mA = 15;
	dcdcInit.em234LoadCurrent_uA = 10;
	dcdcInit.maxCurrent_mA = 200;
	dcdcInit.anaPeripheralPower = emuDcdcAnaPeripheralPower_DCDC;
	dcdcInit.reverseCurrentControl = 160;

	EMU_DCDCInit(&dcdcInit);
	// [EMU Initialization]$

}

//================================================================================
// LFXO_enter_DefaultMode_from_RESET
//================================================================================
extern void LFXO_enter_DefaultMode_from_RESET(void) {

}

//================================================================================
// CMU_enter_DefaultMode_from_RESET
//================================================================================
extern void CMU_enter_DefaultMode_from_RESET(void) {

	// $[High Frequency Clock Setup]
	/* Initializing HFXO */
	CMU_HFXOInit_TypeDef hfxoInit = CMU_HFXOINIT_DEFAULT;

	hfxoInit.autoStartEm01 = 1;

	CMU_HFXOInit(&hfxoInit);

	/* Skipping HFXO oscillator enable, as it is auto-enabled on EM0/EM1 entry */

	/* Setting system HFXO frequency */
	SystemHFXOClockSet(38400000);

	/* Using HFXO as high frequency clock, HFCLK */
	CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFXO);

	/* HFRCO not needed when using HFXO */
	CMU_OscillatorEnable(cmuOsc_HFRCO, false, false);
	// [High Frequency Clock Setup]$

	// $[LE clocks enable]
	/* Enable clock to LE modules */
	CMU_ClockEnable(cmuClock_CORELE, true);
	/* Initializing LFXO */
	CMU_LFXOInit_TypeDef lfxoInit = CMU_LFXOINIT_DEFAULT;

	lfxoInit.ctune = 32;

	CMU_LFXOInit(&lfxoInit);

	/* Enable LFXO oscillator, and wait for it to be stable */
	CMU_OscillatorEnable(cmuOsc_LFXO, true, true);

	/* Setting system LFXO frequency */
	SystemLFXOClockSet(32768);

	// [LE clocks enable]$

	// $[LFACLK Setup]
	/* Select LFXO as clock source for LFACLK */
	CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO);
	// [LFACLK Setup]$

	// $[LFBCLK Setup]
	/* Select LFXO as clock source for LFBCLK */
	CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO);
	// [LFBCLK Setup]$

	// $[LFECLK Setup]
	/* Select LFXO as clock source for LFECLK */
	CMU_ClockSelectSet(cmuClock_LFE, cmuSelect_LFXO);
	// [LFECLK Setup]$

	// $[Peripheral Clock enables]
	/* Enable clock for GPCRC */
	CMU_ClockEnable(cmuClock_GPCRC, true);

	/* Enable clock for LDMA */
	CMU_ClockEnable(cmuClock_LDMA, true);

	/* Enable clock for PRS */
	CMU_ClockEnable(cmuClock_PRS, true);

	/* Enable clock for RTCC */
	CMU_ClockEnable(cmuClock_RTCC, true);

	/* Enable clock for GPIO by default */
	CMU_ClockEnable(cmuClock_GPIO, true);

	// [Peripheral Clock enables]$

	// $[Clock output]
	/* Disable CLKOUT0 output */
	CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_CLKOUTSEL0_MASK)
			| CMU_CTRL_CLKOUTSEL0_DISABLED;
	/* Disable CLKOUT1 output */
	CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_CLKOUTSEL1_MASK)
			| CMU_CTRL_CLKOUTSEL1_DISABLED;

	// [Clock output]$

	// $[CMU_IO]
	/* Disable CLKOUT0 pin */
	CMU->ROUTEPEN &= ~CMU_ROUTEPEN_CLKOUT0PEN;

	/* Disable CLKOUT1 pin */
	CMU->ROUTEPEN &= ~CMU_ROUTEPEN_CLKOUT1PEN;

	// [CMU_IO]$

}

//================================================================================
// ADC0_enter_DefaultMode_from_RESET
//================================================================================
extern void ADC0_enter_DefaultMode_from_RESET(void) {

	// $[ADC0_Init]
	// [ADC0_Init]$

	// $[ADC0_InputConfiguration]
	// [ADC0_InputConfiguration]$

}

//================================================================================
// ACMP0_enter_DefaultMode_from_RESET
//================================================================================
extern void ACMP0_enter_DefaultMode_from_RESET(void) {

	// $[ACMP0_Init]
	// [ACMP0_Init]$

	// $[ACMP0_IO]
	// [ACMP0_IO]$

}

//================================================================================
// ACMP1_enter_DefaultMode_from_RESET
//================================================================================
extern void ACMP1_enter_DefaultMode_from_RESET(void) {

	// $[ACMP1_Init]
	// [ACMP1_Init]$

	// $[ACMP1_IO]
	// [ACMP1_IO]$

}

//================================================================================
// IDAC0_enter_DefaultMode_from_RESET
//================================================================================
extern void IDAC0_enter_DefaultMode_from_RESET(void) {

}

//================================================================================
// RTCC_enter_DefaultMode_from_RESET
//================================================================================
extern void RTCC_enter_DefaultMode_from_RESET(void) {

	// $[Compare/Capture Channel 0 init]
	// [Compare/Capture Channel 0 init]$

	// $[Compare/Capture Channel 1 init]
	// [Compare/Capture Channel 1 init]$

	// $[Compare/Capture Channel 2 init]
	// [Compare/Capture Channel 2 init]$

	// $[RTCC init]
	RTCC_Init_TypeDef rtccInit = RTCC_INIT_DEFAULT;

	rtccInit.enable = true;
	rtccInit.debugRun = false;
	rtccInit.precntWrapOnCCV0 = false;
	rtccInit.cntWrapOnCCV1 = false;
	rtccInit.prescMode = rtccCntTickPresc;
	rtccInit.presc = rtccCntPresc_32;
	rtccInit.enaOSCFailDetect = false;
	rtccInit.cntMode = rtccCntModeNormal;

	RTCC_Init(&rtccInit);
	// [RTCC init]$

}

//================================================================================
// USART0_enter_DefaultMode_from_RESET
//================================================================================
extern void USART0_enter_DefaultMode_from_RESET(void) {

	// $[USART_InitAsync]
	// [USART_InitAsync]$

	// $[USART_InitSync]
	// [USART_InitSync]$

	// $[USART_InitPrsTrigger]
	// [USART_InitPrsTrigger]$

	// $[USART_InitIO]
	// [USART_InitIO]$

	// $[USART_Misc]
	// [USART_Misc]$

	// $[USART_Enable]
	// [USART_Enable]$

}

//================================================================================
// USART1_enter_DefaultMode_from_RESET
//================================================================================
extern void USART1_enter_DefaultMode_from_RESET(void) {

	// $[USART_InitAsync]
	// [USART_InitAsync]$

	// $[USART_InitSync]
	// [USART_InitSync]$

	// $[USART_InitPrsTrigger]
	// [USART_InitPrsTrigger]$

	// $[USART_InitIO]
	// [USART_InitIO]$

	// $[USART_Misc]
	// [USART_Misc]$

	// $[USART_Enable]
	// [USART_Enable]$

}

//================================================================================
// LEUART0_enter_DefaultMode_from_RESET
//================================================================================
extern void LEUART0_enter_DefaultMode_from_RESET(void) {

	// $[LEUART0 initialization]
	 /* Enable peripheral clocks */
	  CMU_ClockEnable(cmuClock_HFPER, true);

	  /* Configure GPIO pins */
	  CMU_ClockEnable(cmuClock_GPIO, true);

	  /* To avoid false start, configure output as high */
	  GPIO_PinModeSet(RETARGET_TXPORT, RETARGET_TXPIN, gpioModePushPull, 1);
	  GPIO_PinModeSet(RETARGET_RXPORT, RETARGET_RXPIN, gpioModeInput, 0);

	  LEUART_Init_TypeDef init = LEUART_INIT_DEFAULT;

	  /* Enable CORE LE clock in order to access LE modules */
	  CMU_ClockEnable(cmuClock_CORELE, true);

	  /* Select LFXO for LEUARTs (and wait for it to stabilize) */
	  CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO);
	  CMU_ClockEnable(cmuClock_LEUART0, true);

	  /* Do not prescale clock */
	  CMU_ClockDivSet(cmuClock_LEUART0, cmuClkDiv_1);

	  /* Configure LEUART */
	  init.enable = leuartDisable;

	  LEUART_Init(LEUART0, &init);

	  /* Enable pins at default location */
	  LEUART0->ROUTELOC0 = (LEUART0->ROUTELOC0 & ~(_LEUART_ROUTELOC0_TXLOC_MASK
	                                               | _LEUART_ROUTELOC0_RXLOC_MASK))
	                       | (RETARGET_TX_LOCATION << _LEUART_ROUTELOC0_TXLOC_SHIFT)
	                       | (RETARGET_RX_LOCATION << _LEUART_ROUTELOC0_RXLOC_SHIFT);

	  LEUART0->ROUTEPEN  = USART_ROUTEPEN_RXPEN | USART_ROUTEPEN_TXPEN;

	  /* Set RXDMAWU to wake up the DMA controller in EM2 */
	  LEUART_RxDmaInEM2Enable(LEUART0, true);

	  /* Finally enable it */
	  LEUART_Enable(LEUART0, leuartEnable);

	  CRYPTO_enter_DefaultMode();

	// [LEUART0 initialization]$

}

//================================================================================
// WDOG0_enter_DefaultMode_from_RESET
//================================================================================
extern void WDOG0_enter_DefaultMode_from_RESET(void) {

	// $[WDOG Initialization]
	// [WDOG Initialization]$

}

//================================================================================
// I2C0_enter_DefaultMode_from_RESET
//================================================================================
extern void I2C0_enter_DefaultMode_from_RESET(void) {

	// $[I2C0 I/O setup]
	// [I2C0 I/O setup]$

	// $[I2C0 initialization]
	// [I2C0 initialization]$

}

//================================================================================
// GPCRC_enter_DefaultMode_from_RESET
//================================================================================
extern void GPCRC_enter_DefaultMode_from_RESET(void) {

}

//================================================================================
// LDMA_enter_DefaultMode_from_RESET
//================================================================================
extern void LDMA_enter_DefaultMode_from_RESET(void) {

	/* LDMA transfer configuration for LEUART */
		const LDMA_TransferCfg_t periTransferRx =
				LDMA_TRANSFER_CFG_PERIPHERAL(ldmaPeripheralSignal_LEUART0_RXDATAV);

		xfer.xfer.dstInc  = ldmaCtrlDstIncOne;

		/* Set the bit to trigger the DMA Done Interrupt */
		xfer.xfer.doneIfs = 1;

		/* LDMA initialization mode definition */
		LDMA_Init_t init = LDMA_INIT_DEFAULT;

		/* Enable the interrupts */
		LDMA->IEN = 0x01;
		NVIC_EnableIRQ(LDMA_IRQn);

		/* LDMA initialization */
		LDMA_Init(&init);
		LDMA_StartTransfer(0, (LDMA_TransferCfg_t *)&periTransferRx, &xfer);

}

//================================================================================
// TIMER0_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER0_enter_DefaultMode_from_RESET(void) {

	// $[TIMER0 I/O setup]
	// [TIMER0 I/O setup]$

	// $[TIMER0 initialization]
	// [TIMER0 initialization]$

	// $[TIMER0 CC0 init]
	// [TIMER0 CC0 init]$

	// $[TIMER0 CC1 init]
	// [TIMER0 CC1 init]$

	// $[TIMER0 CC2 init]
	// [TIMER0 CC2 init]$

	// $[TIMER0 DTI init]
	// [TIMER0 DTI init]$

}

//================================================================================
// TIMER1_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER1_enter_DefaultMode_from_RESET(void) {

	// $[TIMER1 I/O setup]
	// [TIMER1 I/O setup]$

	// $[TIMER1 initialization]
	// [TIMER1 initialization]$

	// $[TIMER1 CC0 init]
	// [TIMER1 CC0 init]$

	// $[TIMER1 CC1 init]
	// [TIMER1 CC1 init]$

	// $[TIMER1 CC2 init]
	// [TIMER1 CC2 init]$

	// $[TIMER1 CC3 init]
	// [TIMER1 CC3 init]$

}

//================================================================================
// LETIMER0_enter_DefaultMode_from_RESET
//================================================================================
extern void LETIMER0_enter_DefaultMode_from_RESET(void) {

	// $[LETIMER0 Compare Values]
	// [LETIMER0 Compare Values]$

	// $[LETIMER0 Repeat Values]
	// [LETIMER0 Repeat Values]$

	// $[LETIMER0 Initialization]
	// [LETIMER0 Initialization]$

	// $[LETIMER0 PRS Input Triggers]
	// [LETIMER0 PRS Input Triggers]$

	// $[LETIMER0 I/O setup]
	// [LETIMER0 I/O setup]$

}

//================================================================================
// CRYOTIMER_enter_DefaultMode_from_RESET
//================================================================================
extern void CRYOTIMER_enter_DefaultMode_from_RESET(void) {

	// $[CRYOTIMER_Init]
	// [CRYOTIMER_Init]$

}

//================================================================================
// PCNT0_enter_DefaultMode_from_RESET
//================================================================================
extern void PCNT0_enter_DefaultMode_from_RESET(void) {

	// $[PCNT0 I/O setup]
	// [PCNT0 I/O setup]$

	// $[PCNT0 initialization]
	// [PCNT0 initialization]$

}

//================================================================================
// PRS_enter_DefaultMode_from_RESET
//================================================================================
extern void PRS_enter_DefaultMode_from_RESET(void) {

	// $[PRS initialization]
	/* Set up DMA triggers */
	PRS->DMAREQ0 |= PRS_DMAREQ0_PRSSEL_PRSCH0;
	PRS->DMAREQ1 |= PRS_DMAREQ1_PRSSEL_PRSCH0;
	// [PRS initialization]$

}

//================================================================================
// PORTIO_enter_DefaultMode_from_RESET
//================================================================================
extern void PORTIO_enter_DefaultMode_from_RESET(void) {

	// $[Port A Configuration]
	// [Port A Configuration]$

	// $[Port B Configuration]
	// [Port B Configuration]$

	// $[Port C Configuration]
	// [Port C Configuration]$

	// $[Port D Configuration]
	// [Port D Configuration]$

	// $[Port E Configuration]
	// [Port E Configuration]$

	// $[Port F Configuration]
	// [Port F Configuration]$

}


void LEUART_IRQHandler()
{
	__enable_irq();

	uint8_t ret = 0;

#if 1
	ret =  mbedtls_aes_crypt_cbc(&aes_ctx,\
			MBEDTLS_AES_DECRYPT,\
			16,\
			initVector,\
			example_input_data,\
			pop_data\
			);
#endif

	__disable_irq();
}

